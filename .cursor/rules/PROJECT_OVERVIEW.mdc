---
description: 
globs: 
alwaysApply: true
---
# Правила создания Rails моделей для Cursor
## 1. Анализ и планирование

**Всегда начинай с полного анализа:**
- Внимательно прочитай требования и выдели все поля, связи, ограничения
- Определи тип связей (belongs_to, has_many, has_and_belongs_to_many, полиморфные)
- Продумай индексы для производительности
- Спланируй валидации и бизнес-логику

## 2. Строгий порядок реализации

**Следуй этой последовательности ВСЕГДА:**
1. **Миграция** с полными ограничениями, индексами, foreign keys
2. **Модель** с валидациями, связями, scopes, методами
3. **Обновление связанных моделей** (добавление обратных связей)
4. **Контроллер** с полным CRUD + дополнительные методы
5. **Маршруты** с collection/member методами
6. **Фабрика** с множественными traits
7. **Тесты** для модели и контроллера
8. **Seeds** с реалистичными данными

## 3. Принципы качества кода

**Никогда не делай минимум - делай правильно:**
- Добавляй все необходимые валидации (presence, uniqueness, format, numericality)
- Создавай полезные scopes для фильтрации
- Добавляй методы типа `full_info`, `formatted_*` для удобства
- Включай статистические методы (count, sum, average)
- Обрабатывай ошибки в контроллерах

## 4. Производительность и безопасность

**Всегда думай о производительности:**
- Добавляй индексы на часто используемые поля
- Используй `includes` для предотвращения N+1 запросов
- Применяй strong parameters в контроллерах
- Добавляй пагинацию и сортировку

## 5. Полнота функциональности

**Контроллеры должны быть полноценными:**
- Стандартный CRUD (index, show, create, update, destroy)
- Фильтрация по основным полям
- Статистические endpoints (stats, analytics)
- Специальные методы для бизнес-логики
- Возвращай полную информацию в JSON responses

## 6. Тестирование и данные

**Создавай качественные тесты:**
- Тестируй все валидации, связи, scopes
- Тестируй все методы контроллера
- Создавай реалистичные фабрики с traits
- Используй осмысленные тестовые данные в seeds
- Проверяй работоспособность после создания

## 7. Решение проблем

**При возникновении ошибок:**
- Не останавливайся на первой ошибке
- Анализируй причину и исправляй системно
- Обновляй все связанные компоненты
- Проверяй работу после исправления

## 8. Мышление о будущем

**Всегда думай о расширяемости:**
- Создавай гибкие связи (полиморфные при необходимости)
- Добавляй поля для будущих нужд (sub_id1-15, timestamps)
- Делай API удобным для фронтенда
- Документируй через понятные названия методов

## 9. Консистентность

**Поддерживай единообразие:**
- Используй одинаковые паттерны именования
- Следуй одной структуре контроллеров
- Применяй одинаковые подходы к валидации
- Используй консистентные форматы JSON responses

## 10. Проверка результата

**Всегда проверяй что создал:**
- Запускай миграции
- Создавай тестовые данные через seeds
- Тестируй основные сценарии использования
- Проверяй работу API endpoints
- Убеждайся что тесты проходят

---

## Пример структуры модели

```ruby
class ModelName < ApplicationRecord
  # Associations
  belongs_to :parent_model
  has_many :child_models, dependent: :destroy
  has_and_belongs_to_many :related_models
  
  # Validations
  validates :name, presence: true, uniqueness: true, length: { minimum: 2, maximum: 100 }
  validates :status, inclusion: { in: %w[active inactive pending] }
  validates :cost, numericality: { greater_than_or_equal_to: 0 }
  
  # Scopes
  scope :active, -> { where(status: 'active') }
  scope :by_name, ->(name) { where(name: name) }
  scope :recent, -> { where('created_at >= ?', 30.days.ago) }
  
  # Instance methods
  def full_info
    {
      id: id,
      name: name,
      status: status,
      # ... other fields
      created_at: created_at,
      updated_at: updated_at
    }
  end
  
  def formatted_cost
    "$#{'%.2f' % cost}"
  end
  
  # Class methods
  def self.total_cost
    sum(:cost)
  end
  
  def self.status_summary
    group(:status).count
  end
end
```

## Пример структуры контроллера

```ruby
class ModelsController < ApplicationController
  include Filterable
  include Paginatable
  include Sortable
  
  before_action :set_model, only: [:show, :update, :destroy]
  
  def index
    models = Model.includes(:associations)
    models = apply_filters(models)
    models = apply_sorting(models)
    models = apply_pagination(models)
    
    render json: {
      models: models.map(&:full_info),
      pagination: pagination_info(models),
      stats: generate_stats
    }
  end
  
  def show
    render json: @model.full_info
  end
  
  def create
    @model = Model.new(model_params)
    
    if @model.save
      render json: @model.full_info, status: :created
    else
      render json: { errors: @model.errors.full_messages }, status: :unprocessable_entity
    end
  end
  
  def update
    if @model.update(model_params)
      render json: @model.full_info
    else
      render json: { errors: @model.errors.full_messages }, status: :unprocessable_entity
    end
  end
  
  def destroy
    @model.destroy
    render json: { message: 'Model deleted successfully' }
  end
  
  def stats
    render json: {
      total_count: Model.count,
      status_breakdown: Model.status_summary,
      # ... other stats
    }
  end
  
  private
  
  def set_model
    @model = Model.find(params[:id])
  rescue ActiveRecord::RecordNotFound
    render json: { error: 'Model not found' }, status: :not_found
  end
  
  def model_params
    params.require(:model).permit(:name, :status, :cost, ...)
  end
  
  def apply_filters(models)
    models = models.where(status: params[:status]) if params[:status].present?
    # ... other filters
    models
  end
  
  def generate_stats
    {
      total_count: Model.count,
      # ... other stats
    }
  end
end
```

---

**Помни: Цель не просто создать модель, а создать полноценную, производительную, безопасную и удобную в использовании часть системы.** 
